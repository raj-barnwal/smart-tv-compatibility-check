<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Decoder Capabilities</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #2a5885;
            margin-bottom: 20px;
        }
        h2 {
            color: #4a76a8;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        li:last-child {
            border-bottom: none;
        }
        .yes {
            color: #4CAF50;
            font-weight: bold;
        }
        .no {
            color: #F44336;
        }
        .codec-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        .codec-item {
            background-color: #fff;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .not-supported {
            opacity: 0.6;
        }
        button {
            background-color: #4a76a8;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
        }
        button:hover {
            background-color: #3a5c82;
        }
        #loadingIndicator {
            display: none;
            margin-bottom: 15px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Browser Decoder Capabilities</h1>
    
    <div class="container">
        <p>This page detects and displays the media codecs supported by your browser. This information is useful for web developers working with audio and video content.</p>
        <p><strong>Special focus:</strong> This tool specifically tests for advanced codec support including Dolby audio formats (EC-3/AC-3) and HDR video capabilities.</p>
        <button id="checkCapabilities">Check Decoder Capabilities</button>
        <div id="loadingIndicator">Testing codecs, please wait...</div>
    </div>

    <div id="results" style="display: none;">
        <div class="container">
            <h2>Browser Information</h2>
            <ul id="browserInfo"></ul>
        </div>

        <div class="container">
            <h2>Media Source Extensions (MSE) Support</h2>
            <ul id="mseSupport"></ul>
        </div>
        
        <div class="container">
            <h2>Video Codecs</h2>
            <div class="codec-grid" id="videoCodecs"></div>
        </div>
        
        <div class="container">
            <h2>HDR Support</h2>
            <ul id="hdrSupport"></ul>
        </div>
        
        <div class="container">
            <h2>Audio Codecs</h2>
            <div class="codec-grid" id="audioCodecs"></div>
        </div>
        
        <div class="container">
            <h2>Dolby Audio Detail Tests</h2>
            <div id="dolbyTests"></div>
        </div>
        
        <div class="container">
            <h2>Container Formats</h2>
            <div class="codec-grid" id="containers"></div>
        </div>
        
        <div class="container">
            <h2>HDCP Support (2.0, 2.1, 2.2)</h2>
            <ul id="hdcpSupport"></ul>
        </div>
    </div>

    <script>
        document.getElementById('checkCapabilities').addEventListener('click', function() {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            
            // Give the UI time to update before running the tests
            setTimeout(checkCapabilities, 100);
        });

        function checkCapabilities() {
            // Browser detection
            const browserInfo = document.getElementById('browserInfo');
            const userAgent = navigator.userAgent;
            
            // Extract browser name and version
            let browserName = "Unknown";
            let browserVersion = "Unknown";
            
            if (userAgent.indexOf("Firefox") > -1) {
                browserName = "Mozilla Firefox";
                browserVersion = userAgent.match(/Firefox\/([0-9.]+)/)[1];
            } else if (userAgent.indexOf("SamsungBrowser") > -1) {
                browserName = "Samsung Internet";
                browserVersion = userAgent.match(/SamsungBrowser\/([0-9.]+)/)[1];
            } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
                browserName = "Opera";
                browserVersion = userAgent.indexOf("Opera") > -1 ? 
                    userAgent.match(/Opera\/([0-9.]+)/)[1] : 
                    userAgent.match(/OPR\/([0-9.]+)/)[1];
            } else if (userAgent.indexOf("Edg") > -1) {
                browserName = "Microsoft Edge";
                browserVersion = userAgent.match(/Edg\/([0-9.]+)/)[1];
            } else if (userAgent.indexOf("Chrome") > -1) {
                browserName = "Google Chrome";
                browserVersion = userAgent.match(/Chrome\/([0-9.]+)/)[1];
            } else if (userAgent.indexOf("Safari") > -1) {
                browserName = "Apple Safari";
                browserVersion = userAgent.match(/Version\/([0-9.]+)/)[1];
            }
            
            browserInfo.innerHTML = `
                <li><strong>Browser:</strong> ${browserName}</li>
                <li><strong>Version:</strong> ${browserVersion}</li>
                <li><strong>User Agent:</strong> ${userAgent}</li>
                <li><strong>Platform:</strong> ${navigator.platform}</li>
            `;
            
            // Check Media Source Extensions support
            const mseSupport = document.getElementById('mseSupport');
            const hasMSE = 'MediaSource' in window;
            
            mseSupport.innerHTML = `
                <li><strong>MediaSource API:</strong> <span class="${hasMSE ? 'yes' : 'no'}">${hasMSE ? 'Yes' : 'No'}</span></li>
                <li><strong>SourceBuffer API:</strong> <span class="${'SourceBuffer' in window ? 'yes' : 'no'}">${'SourceBuffer' in window ? 'Yes' : 'No'}</span></li>
            `;
            
            // Check for MSE with EC-3 and EAC-3 support
            if (hasMSE) {
                const mseCodecTests = [
                    'video/webm; codecs="vp8"',
                    'video/webm; codecs="vp9"',
                    'video/webm; codecs="av1"',
                    'video/mp4; codecs="avc1.42E01E"', // H.264 Baseline
                    'video/mp4; codecs="avc1.64001E"', // H.264 High
                    'video/mp4; codecs="hev1.1.6.L93.B0"', // HEVC/H.265
                    'video/mp4; codecs="hvc1"', // HEVC/H.265 alternative
                    'audio/mp4; codecs="ec-3"', // EC-3 (Dolby Digital Plus)
                    'audio/mp4; codecs="ac-3"', // AC-3 (Dolby Digital)
                    'video/mp4; codecs="avc1.64001E, ec-3"', // H.264 + EC-3
                    'video/mp4; codecs="hevc, ec-3"', // HEVC + EC-3
                ];
                
                mseCodecTests.forEach(type => {
                    const isSupported = MediaSource.isTypeSupported(type);
                    mseSupport.innerHTML += `
                        <li><strong>${type}:</strong> <span class="${isSupported ? 'yes' : 'no'}">${isSupported ? 'Yes' : 'No'}</span></li>
                    `;
                });
            }
            
            // Check video codecs support
            const videoCodecs = [
                { name: 'H.264 (AVC) Baseline', type: 'video/mp4; codecs="avc1.42E01E"' },
                { name: 'H.264 (AVC) Main', type: 'video/mp4; codecs="avc1.4D401E"' },
                { name: 'H.264 (AVC) High', type: 'video/mp4; codecs="avc1.64001E"' },
                { name: 'H.265 (HEVC)', type: 'video/mp4; codecs="hev1.1.6.L93.B0"' },
                { name: 'H.265 (HEVC) HDR10', type: 'video/mp4; codecs="hev1.2.4.L153.B0"' },
                { name: 'VP8', type: 'video/webm; codecs="vp8"' },
                { name: 'VP9', type: 'video/webm; codecs="vp9"' },
                { name: 'VP9 HDR', type: 'video/webm; codecs="vp9.2"' },
                { name: 'AV1', type: 'video/mp4; codecs="av01.0.01M.08"' },
                { name: 'AV1 HDR', type: 'video/mp4; codecs="av01.0.13M.10.0.110.09.16.09.0"' },
                { name: 'Theora', type: 'video/ogg; codecs="theora"' }
            ];
            
            const videoElement = document.createElement('video');
            const videoCodecsContainer = document.getElementById('videoCodecs');
            
            videoCodecs.forEach(codec => {
                const canPlay = videoElement.canPlayType(codec.type);
                const supportLevel = canPlay === 'probably' ? 'Full support' : 
                                    canPlay === 'maybe' ? 'Partial support' : 'Not supported';
                const className = canPlay === '' ? 'codec-item not-supported' : 'codec-item';
                
                videoCodecsContainer.innerHTML += `
                    <div class="${className}">
                        <strong>${codec.name}</strong><br>
                        Status: <span class="${canPlay !== '' ? 'yes' : 'no'}">${supportLevel}</span><br>
                        <small>${codec.type}</small>
                    </div>
                `;
            });
            
            // Check audio codecs support
            const audioCodecs = [
                { name: 'AAC-LC', type: 'audio/mp4; codecs="mp4a.40.2"' },
                { name: 'AAC-HE', type: 'audio/mp4; codecs="mp4a.40.5"' },
                { name: 'MP3', type: 'audio/mpeg' },
                { name: 'Opus', type: 'audio/ogg; codecs="opus"' },
                { name: 'Vorbis', type: 'audio/ogg; codecs="vorbis"' },
                { name: 'FLAC', type: 'audio/flac' },
                { name: 'WAV (PCM)', type: 'audio/wav' },
                { name: 'WebM Audio', type: 'audio/webm' },
                { name: 'Dolby Digital (AC-3)', type: 'audio/mp4; codecs="ac-3"' },
                { name: 'Dolby Digital Plus (EC-3)', type: 'audio/mp4; codecs="ec-3"' },
                { name: 'Dolby Digital Plus (EC-3) Alt', type: 'audio/mp4; codecs="ec-3"' },
                { name: 'Dolby Digital Plus (DD+)', type: 'audio/mp4; codecs="ddp"' },
                { name: 'Dolby TrueHD', type: 'audio/mp4; codecs="truehd"' },
                { name: 'Dolby AC-4', type: 'audio/mp4; codecs="ac-4"' },
                { name: 'Dolby Atmos (EC-3 JOC)', type: 'audio/mp4; codecs="ec+3"' },
                { name: 'Dolby Atmos (EC-3 with JOC)', type: 'audio/mp4; codecs="ec-3+joc"' }
            ];
            
            const audioElement = document.createElement('audio');
            const audioCodecsContainer = document.getElementById('audioCodecs');
            
            audioCodecs.forEach(codec => {
                const canPlay = audioElement.canPlayType(codec.type);
                const supportLevel = canPlay === 'probably' ? 'Full support' : 
                                    canPlay === 'maybe' ? 'Partial support' : 'Not supported';
                const className = canPlay === '' ? 'codec-item not-supported' : 'codec-item';
                
                audioCodecsContainer.innerHTML += `
                    <div class="${className}">
                        <strong>${codec.name}</strong><br>
                        Status: <span class="${canPlay !== '' ? 'yes' : 'no'}">${supportLevel}</span><br>
                        <small>${codec.type}</small>
                    </div>
                `;
            });
            
            // Check container formats
            const containers = [
                { name: 'MP4', type: 'video/mp4' },
                { name: 'WebM', type: 'video/webm' },
                { name: 'Ogg', type: 'video/ogg' },
                { name: '3GPP', type: 'video/3gpp' },
                { name: 'QuickTime', type: 'video/quicktime' },
                { name: 'MPEG-TS', type: 'video/mp2t' },
                { name: 'M4A', type: 'audio/m4a' },
                { name: 'WAV', type: 'audio/wav' }
            ];
            
            const containersContainer = document.getElementById('containers');
            
            containers.forEach(container => {
                const videoCanPlay = videoElement.canPlayType(container.type);
                const audioCanPlay = audioElement.canPlayType(container.type);
                const canPlay = videoCanPlay || audioCanPlay;
                
                const supportLevel = (videoCanPlay === 'probably' || audioCanPlay === 'probably') ? 'Full support' : 
                                    (videoCanPlay === 'maybe' || audioCanPlay === 'maybe') ? 'Partial support' : 'Not supported';
                const className = canPlay === '' ? 'codec-item not-supported' : 'codec-item';
                
                containersContainer.innerHTML += `
                    <div class="${className}">
                        <strong>${container.name}</strong><br>
                        Status: <span class="${canPlay !== '' ? 'yes' : 'no'}">${supportLevel}</span><br>
                        <small>${container.type}</small>
                    </div>
                `;
            });
            
            // Check HDR support
            const hdrSupport = document.getElementById('hdrSupport');
            
            // Check for HDR-related APIs and properties
            const hasCanvasColorManagement = 'getContextAttributes' in document.createElement('canvas').getContext('2d') && 
                                              document.createElement('canvas').getContext('2d').getContextAttributes() && 
                                              'colorSpace' in document.createElement('canvas').getContext('2d').getContextAttributes();
            
            const hasMatchMediaHDR = 'matchMedia' in window && 
                                     (window.matchMedia('(dynamic-range: high)').matches || 
                                      window.matchMedia('(color-gamut: p3)').matches ||
                                      window.matchMedia('(color-gamut: rec2020)').matches);
            
            const hasDisplayP3Support = CSS.supports('color', 'color(display-p3 1 1 1)');
            
            hdrSupport.innerHTML = `
                <li><strong>Color Management API:</strong> <span class="${hasCanvasColorManagement ? 'yes' : 'no'}">${hasCanvasColorManagement ? 'Yes' : 'No'}</span></li>
                <li><strong>Display P3 Color Space:</strong> <span class="${hasDisplayP3Support ? 'yes' : 'no'}">${hasDisplayP3Support ? 'Yes' : 'No'}</span></li>
                <li><strong>Media Query HDR Support:</strong> <span class="${hasMatchMediaHDR ? 'yes' : 'no'}">${hasMatchMediaHDR ? 'Yes' : 'No'}</span></li>
            `;
            
            // Check for specific color gamuts with media queries
            if ('matchMedia' in window) {
                const colorGamuts = [
                    { name: 'sRGB', query: '(color-gamut: srgb)' },
                    { name: 'P3 (Wide Color)', query: '(color-gamut: p3)' },
                    { name: 'Rec.2020 (Ultra Wide Color)', query: '(color-gamut: rec2020)' }
                ];
                
                colorGamuts.forEach(gamut => {
                    const isSupported = window.matchMedia(gamut.query).matches;
                    hdrSupport.innerHTML += `
                        <li><strong>${gamut.name} Color Gamut:</strong> <span class="${isSupported ? 'yes' : 'no'}">${isSupported ? 'Yes' : 'No'}</span></li>
                    `;
                });
                
                // Check for dynamic range
                const dynamicRanges = [
                    { name: 'Standard Dynamic Range (SDR)', query: '(dynamic-range: standard)' },
                    { name: 'High Dynamic Range (HDR)', query: '(dynamic-range: high)' }
                ];
                
                dynamicRanges.forEach(range => {
                    // Some browsers might not support this media query syntax
                    try {
                        const isSupported = window.matchMedia(range.query).matches;
                        hdrSupport.innerHTML += `
                            <li><strong>${range.name}:</strong> <span class="${isSupported ? 'yes' : 'no'}">${isSupported ? 'Yes' : 'No'}</span></li>
                        `;
                    } catch (e) {
                        hdrSupport.innerHTML += `
                            <li><strong>${range.name}:</strong> <span class="no">Not detected (query not supported)</span></li>
                        `;
                    }
                });
            }
            
            // Detailed Dolby tests
            const dolbyTestsContainer = document.getElementById('dolbyTests');
            
            // Create test variations for EC-3/EAC-3 (Dolby Digital Plus)
            const dolbyVariations = [
                { name: 'EC-3 in MP4', type: 'audio/mp4; codecs="ec-3"' },
                { name: 'EC-3 Direct', type: 'audio/ec-3' },
                { name: 'EAC-3 in MP4', type: 'audio/mp4; codecs="eac-3"' },
                { name: 'EAC-3 Direct', type: 'audio/eac-3' },
                { name: 'MP4 with EC-3', type: 'video/mp4; codecs="avc1.64001E, ec-3"' },
                { name: 'AC-3 in MP4', type: 'audio/mp4; codecs="ac-3"' },
                { name: 'AC-3 Direct', type: 'audio/ac-3' },
                { name: 'MP4 with AC-3', type: 'video/mp4; codecs="avc1.64001E, ac-3"' }
            ];
            
            // Create a table for Dolby test results
            let dolbyTable = '<table style="width:100%; border-collapse: collapse; margin-top: 10px;">';
            dolbyTable += '<tr><th style="text-align:left; padding:8px; background-color:#f2f2f2; border:1px solid #ddd;">Format</th><th style="text-align:left; padding:8px; background-color:#f2f2f2; border:1px solid #ddd;">Audio Element</th><th style="text-align:left; padding:8px; background-color:#f2f2f2; border:1px solid #ddd;">MSE</th></tr>';
            
            dolbyVariations.forEach(variation => {
                const audioCanPlay = audioElement.canPlayType(variation.type);
                const mseSupported = ('MediaSource' in window) ? MediaSource.isTypeSupported(variation.type) : 'N/A';
                
                const audioSupportClass = audioCanPlay !== '' ? 'yes' : 'no';
                const mseSupportClass = mseSupported === true ? 'yes' : (mseSupported === false ? 'no' : '');
                
                dolbyTable += `<tr>
                    <td style="padding:8px; border:1px solid #ddd;">${variation.name}<br><small>${variation.type}</small></td>
                    <td style="padding:8px; border:1px solid #ddd;"><span class="${audioSupportClass}">${audioCanPlay || 'No'}</span></td>
                    <td style="padding:8px; border:1px solid #ddd;"><span class="${mseSupportClass}">${mseSupported === 'N/A' ? 'N/A' : (mseSupported ? 'Yes' : 'No')}</span></td>
                </tr>`;
            });
            
            dolbyTable += '</table>';
            dolbyTestsContainer.innerHTML = dolbyTable;
            
            // Check HDCP support (2.0, 2.1, 2.2)
            Promise.all([
                checkHdcp20Support(),
                checkHdcp21Support(),
                checkHdcp22Support()
            ]).then(([hdcp20, hdcp21, hdcp22]) => {
                const hdcpSupport = document.getElementById('hdcpSupport');
                hdcpSupport.innerHTML = `
                    <li><strong>HDCP 2.0 Support:</strong> <span class="${hdcp20 ? 'yes' : 'no'}">${hdcp20 ? 'Yes' : 'No'}</span></li>
                    <li><strong>HDCP 2.1 Support:</strong> <span class="${hdcp21 ? 'yes' : 'no'}">${hdcp21 ? 'Yes' : 'No'}</span></li>
                    <li><strong>HDCP 2.2 Support:</strong> <span class="${hdcp22 ? 'yes' : 'no'}">${hdcp22 ? 'Yes' : 'No'}</span></li>
                `;
                
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('results').style.display = 'block';
            }).catch(err => {
                const hdcpSupport = document.getElementById('hdcpSupport');
                hdcpSupport.innerHTML = `
                    <li><strong>HDCP 2.0 Support:</strong> <span class="no">Error checking support</span></li>
                    <li><strong>HDCP 2.1 Support:</strong> <span class="no">Error checking support</span></li>
                    <li><strong>HDCP 2.2 Support:</strong> <span class="no">Error checking support</span></li>
                `;
                
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('results').style.display = 'block';
            });
        }

        async function supportsHdcp22() {
            try {
                if (!navigator?.requestMediaKeySystemAccess) return false;

                // Test configurations with different codec combinations
                const testConfigurations = [
                    // Test 1: HEVC with hardware security (strictest - HDCP 2.2)
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="hev1.1.6.L153.B0"',
                                robustness: "HW_SECURE_ALL"
                            }]
                        }]
                    },
                    // Test 2: Alternative HEVC format
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="hvc1.1.6.L153.B0"',
                                robustness: "HW_SECURE_ALL"
                            }]
                        }]
                    },
                    // Test 3: AVC with high robustness (may indicate HDCP 2.2)
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.640033"',
                                robustness: "HW_SECURE_ALL"
                            }]
                        }]
                    },
                    // Test 4: PlayReady HEVC
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="hev1.1.6.L153.B0"',
                                robustness: "3000"
                            }]
                        }]
                    },
                    // Test 5: PlayReady AVC with high robustness
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.640033"',
                                robustness: "3000"
                            }]
                        }]
                    }
                ];

                for (const testConfig of testConfigurations) {
                    try {
                        await navigator.requestMediaKeySystemAccess(testConfig.name, testConfig.config);
                        console.log(`HDCP 2.2 Support detected with: ${testConfig.name}`, testConfig.config[0].videoCapabilities[0]);
                        return true;
                    } catch (err) {
                        // Continue to next test
                        console.debug(`Failed test for ${testConfig.name}:`, err.message || err);
                    }
                }

                console.warn("HDCP 2.2 not supported - all tests failed");
                return false;
            } catch (err) {
                console.error("Error checking HDCP 2.2 support:", err);
                return false;
            }
        }

        async function supportsHdcp20() {
            try {
                if (!navigator?.requestMediaKeySystemAccess) return false;

                // Test configurations for HDCP 2.0 (lower robustness requirements)
                const testConfigurations = [
                    // Test 1: Widevine with software security (HDCP 2.0 level)
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "SW_SECURE_CRYPTO"
                            }]
                        }]
                    },
                    // Test 2: Widevine with basic hardware security
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "HW_SECURE_CRYPTO"
                            }]
                        }]
                    },
                    // Test 3: PlayReady with lower robustness (HDCP 2.0)
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "2000"
                            }]
                        }]
                    },
                    // Test 4: PlayReady with medium-low robustness
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "2500"
                            }]
                        }]
                    }
                ];

                for (const testConfig of testConfigurations) {
                    try {
                        await navigator.requestMediaKeySystemAccess(testConfig.name, testConfig.config);
                        console.log(`HDCP 2.0 Support detected with: ${testConfig.name}`, testConfig.config[0].videoCapabilities[0]);
                        return true;
                    } catch (err) {
                        console.debug(`Failed HDCP 2.0 test for ${testConfig.name}:`, err.message || err);
                    }
                }

                console.warn("HDCP 2.0 not supported - all tests failed");
                return false;
            } catch (err) {
                console.error("Error checking HDCP 2.0 support:", err);
                return false;
            }
        }

        async function supportsHdcp21() {
            try {
                if (!navigator?.requestMediaKeySystemAccess) return false;

                // Test configurations for HDCP 2.1 (medium robustness requirements)
                const testConfigurations = [
                    // Test 1: Widevine with hardware security (HDCP 2.1 level)
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "HW_SECURE_DECODE"
                            }]
                        }]
                    },
                    // Test 2: Widevine HEVC with medium hardware security
                    {
                        name: "com.widevine.alpha",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="hev1.1.6.L93.B0"',
                                robustness: "HW_SECURE_DECODE"
                            }]
                        }]
                    },
                    // Test 3: PlayReady with medium-high robustness (HDCP 2.1)
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="avc1.64001E"',
                                robustness: "2700"
                            }]
                        }]
                    },
                    // Test 4: PlayReady HEVC with medium robustness
                    {
                        name: "com.microsoft.playready",
                        config: [{
                            initDataTypes: ["cenc"],
                            videoCapabilities: [{
                                contentType: 'video/mp4; codecs="hev1.1.6.L93.B0"',
                                robustness: "2700"
                            }]
                        }]
                    }
                ];

                for (const testConfig of testConfigurations) {
                    try {
                        await navigator.requestMediaKeySystemAccess(testConfig.name, testConfig.config);
                        console.log(`HDCP 2.1 Support detected with: ${testConfig.name}`, testConfig.config[0].videoCapabilities[0]);
                        return true;
                    } catch (err) {
                        console.debug(`Failed HDCP 2.1 test for ${testConfig.name}:`, err.message || err);
                    }
                }

                console.warn("HDCP 2.1 not supported - all tests failed");
                return false;
            } catch (err) {
                console.error("Error checking HDCP 2.1 support:", err);
                return false;
            }
        }

        async function checkHdcp20Support() {
            return await supportsHdcp20();
        }

        async function checkHdcp21Support() {
            return await supportsHdcp21();
        }

        async function checkHdcp22Support() {
            return await supportsHdcp22();
        }
    </script>
</body>
</html>
